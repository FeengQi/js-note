本章内容
 - 使用高级函数
 - 防篡改对象
 - Yielding Timers

### 22.1  高级函数

#### 22.1.1 安全的类型检测

- instanceof 操作符在存在多个全局作用域（像一个页面包含多个 frame）的情况下，有问题：
```
var isArray = value instanceof Array;
```
以上代码要返回 true，value 必须是一个数组，而且还必须与 Array 构造函数在同个全局作用域中。（Array 是 window 的属性）如果 value 是在另个 frame 中定义的数组，那么以上代码就会返回 false。

- 类型检测 - 完美解决方案：由于原生数组的构造函数名与全局作用域无关，因此使用 toString()就能保证返回一致的值。
```
Object.prototype.toString.call(value)
```
Object 的 toString()方法不能检测非原生构造函数的构造函数名。

#### 22.1.2 作用域安全带额构造函数

- 构造函数其实就是一个使用 new 操作符调用的函数。当使用 new 调用时，构造函数内用到的 this 对象会指向新创建的对象实例
```
function Person(name, age, job){
 this.name = name;
 this.age = age;
 this.job = job;
}
var person = new Person("Nicholas", 29, "Software Engineer");
```
当没有使用 new操作符来调用该构造函数的情况上。由于该 this 对象是在运行时绑定的，所以直接调用 Person()，this 会映射到全局对象 window 上，导致错误对象属性的意外增加。
例如：
```
var person = Person("Nicholas", 29, "Software Engineer");
alert(window.name);    //"Nicholas"
alert(window.age);     //29
alert(window.job);     //"Software Engineer" 
```
- 解决办法：创建一个'作用域安全的构造函数'
作用域安全的构造函数在进行任何更改前，首先确认 this 对象是正确类型的实例。如果不是，那么会创建新的实例并返回
```
function Person(name, age, job){
 if (this instanceof Person){
 this.name = name;
 this.age = age;
 this.job = job;
 } else {
 return new Person(name, age, job);
 }
}
var person1 = Person("Nicholas", 29, "Software Engineer");
alert(window.name);    //""
alert(person1.name);   //"Nicholas"
var person2 = new Person("Shelby", 34, "Ergonomist");
alert(person2.name);   //"Shelby" 
```

